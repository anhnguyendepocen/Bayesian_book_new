# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
HMC(c(-2.88,-2.43),U,grad_U,0.18,20,0.18)
?Reduce
HMC1 <- function (aDummy,current_q, U, grad_U, epsilon, L, aSigma){
q = current_q
p = rnorm(length(q),0,aSigma)  # independent standard normal variates
current_p = p
# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
lSamples <- Reduce(function(a,b) HMC1(a,b,U,grad_U,0.18,20,0.18),lSeq(1,20),init = c(-2,-2))
lSamples <- Reduce(function(a,b) HMC1(a,b,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2))
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2))
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2),accumulate = T)
lSamples <- unlist(Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2),accumulate = T))
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2),accumulate = T)
lSamples <- as.data.frame(Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2),accumulate = T))
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2),accumulate = T)
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2),accumulate = T)
library(ggplot2)
library(plyr)
lSamples <- ldply(lSamples,data.frame)
View(lSamples)
lSamples <- ldply(lSamples,rbind.data.frame)
lSamples <- ldply(lSamples,rbind)
View(lSamples)
lSamples <- ldply(lSamples,cbind)
View(lSamples)
lSamples <- data.frame(matrix(unlist(lSamples)))
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,20),init = c(-2,-2),accumulate = T)
lSamples <- data.frame(matrix(unlist(lSamples)))
lSamples <- data.frame(matrix(unlist(lSamples),ncol=2))
View(lSamples)
lSamples <- data.frame(matrix(unlist(lSamples),ncol=2,byrow = T))
View(lSamples)
View(lSamples)
ggplot(lSamples,aes(x=X1,y=X2)) + geom_path()
ggplot(lSamples,aes(x=X1,y=X2)) + geom_path() + xlim(-5,5) + ylim(-5,5)
nIterations <- 100
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,nIterations),init = c(-2,-2),accumulate = T)
lSamples <- data.frame(matrix(unlist(lSamples),ncol=2,byrow = T))
ggplot(lSamples,aes(x=X1,y=X2)) + geom_path() + xlim(-5,5) + ylim(-5,5)
nIterations <- 100
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,nIterations),init = c(-2,-2),accumulate = T)
lSamples <- data.frame(matrix(unlist(lSamples),ncol=2,byrow = T))
ggplot(lSamples,aes(x=X1,y=X2)) + geom_path() + xlim(-5,5) + ylim(-5,5)
ggplot(lSamples,aes(x=X1,y=X2)) + geom_path()
nIterations <- 1000
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,nIterations),init = c(-2,-2),accumulate = T)
lSamples <- data.frame(matrix(unlist(lSamples),ncol=2,byrow = T))
ggplot(lSamples,aes(x=X1,y=X2)) + geom_path()
mSamples <- matrix(nrow=nIterations,ncol=2)
mSamples[,1] <- c(1,1)
fHMCAllSteps <- function(nIterations,start_q,U, grad_U, epsilon, L, aSigma){
mSamples <- matrix(nrow=nIterations,ncol=2)
mSamples[1,] <- start_q
current_q <- start_q
for (i in 1:nIterations){
current_q <- HMC(current_q, U, grad_U, epsilon, L, aSigma)
mSamples[i,] <- current_q
}
return(mSamples)
}
fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18)
lSamples <- fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18)
View(lSamples)
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
lSamples <- as.data.frame(fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18))
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
lSamples <- as.data.frame(fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18))
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
lSamples <- as.data.frame(fHMCAllSteps(1000,c(-4,-4),U,grad_U,0.18,20,0.18))
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
lSamples <- as.data.frame(fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18))
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
outer(seq(-5,5,1),seq(-5,5,1),U)
outer(seq(-5,5,1),seq(-5,5,1),function(x,y) U(c(x,y)))
outer(seq(-5,5,1),seq(-5,5,1),function(x,y) c(x,y))
?outer
outer(seq(-5,5,1),seq(-5,5,1),function(x,y) x*y)
outer(seq(-5,5,1),seq(-5,5,1),function(x,y) c(x,y))
outer(seq(-5,5,1),seq(-5,5,1),function(x,y) c(x,y))
outer(seq(-5,5,1),seq(-5,5,1),FUN = function(x,y) c(x,y))
outer(seq(-5,5,1),seq(-5,5,1),FUN = function(x,y) list(x,y))
outer(seq(-5,5,1),seq(-5,5,1),FUN = function(x,y) x/y)
outer(seq(-5,5,1),seq(-5,5,1),FUN = function(x,y) U(x,y))
outer(seq(-5,5,1),seq(-5,5,1),FUN = function(x,y) "U(x,y)")
outer(seq(-5,5,1),seq(-5,5,1),FUN = function(x,y) "U(c(x,y)")
outer(seq(-5,5,1),seq(-5,5,1))
outer(seq(-5,5,1),seq(-5,5,1),"^")
outer(seq(-5,5,1),seq(-5,5,1),"U(x,y)")
outer(seq(-5,5,1),seq(-5,5,1),"U(c(x,y)")
outer(seq(-5,5,1),seq(-5,5,1),"U")
lSamples <- as.data.frame(fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18))
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
lSamples <- as.data.frame(fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18))
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
U(c(1,1))
U(c(1,5))
U(c(-1,5))
fGradSimpleX(c(1,1))
fGradSimpleX(1,1)
fGradSimpleX <- function(x,y){
aGrad <- -0.5 * exp(0.5 * (-x * (10.2564 * x - 9.74359 * y) - y * (-9.74359 * x + 10.2564 * y)) +
0.5 * (x * (10.2564 * x - 9.74359 * y) +
y * (-9.74359 * x + 10.2564 * y))) (-20.5128 * x + 19.4872 * y)
return(aGrad)
}
fGradSimpleX(1,1)
fGradSimpleX(1,1)
fGradSimpleX <- function(x,y){
aGrad <- -0.5 * exp(0.5 * (-x * (10.2564 * x - 9.74359 * y) - y * (-9.74359 * x + 10.2564 * y)) +
0.5 * (x * (10.2564 * x - 9.74359 * y) +
y * (-9.74359 * x + 10.2564 * y))) * (-20.5128 * x + 19.4872 * y)
return(aGrad)
}
fGradSimpleX(1,1)
fGradSimpleY <- function(x,y){
return(fGradSimpleX(y,x))
}
rm(list=ls())
library(ggplot2)
library(plyr)
HMC <- function (current_q, U, grad_U, epsilon, L, aSigma){
q = current_q
p = rnorm(length(q),0,aSigma)  # independent standard normal variates
current_p = p
# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
fGradSimpleX <- function(x,y){
aGrad <- -0.5 * exp(0.5 * (-x * (10.2564 * x - 9.74359 * y) - y * (-9.74359 * x + 10.2564 * y)) +
0.5 * (x * (10.2564 * x - 9.74359 * y) +
y * (-9.74359 * x + 10.2564 * y))) * (-20.5128 * x + 19.4872 * y)
return(aGrad)
}
fGradSimpleY <- function(x,y){
return(fGradSimpleX(y,x))
}
grad_U <- function(aQ){
aGradX <- fGradSimpleX(aQ[[1]],aQ[[2]])
aGrady <- fGradSimpleY(aQ[[1]],aQ[[2]])
return(c(aGradX,aGrady))
}
U <- function(aQ){
x <- aQ[[1]]
y <- aQ[[2]]
aU <- -log(0.509704 * exp(
0.5 * (-x * (10.2564 * x - 9.74359 * y) - y * (-9.74359 * x + 10.2564 * y))))
return(aU)
}
HMC(c(-2.88,-2.43),U,grad_U,0.18,20,0.18)
HMC1 <- function (aDummy,current_q, U, grad_U, epsilon, L, aSigma){
q = current_q
p = rnorm(length(q),0,aSigma)  # independent standard normal variates
current_p = p
# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
nIterations <- 1000
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,nIterations),init = c(-2,-2),accumulate = T)
lSamples <- data.frame(matrix(unlist(lSamples),ncol=2,byrow = T))
ggplot(lSamples,aes(x=X1,y=X2)) + geom_path()
fHMCAllSteps <- function(nIterations,start_q,U, grad_U, epsilon, L, aSigma){
mSamples <- matrix(nrow=nIterations,ncol=2)
mSamples[1,] <- start_q
current_q <- start_q
for (i in 1:nIterations){
current_q <- HMC(current_q, U, grad_U, epsilon, L, aSigma)
mSamples[i,] <- current_q
}
return(mSamples)
}
lSamples <- as.data.frame(fHMCAllSteps(100,c(-4,-4),U,grad_U,0.18,20,0.18))
ggplot(lSamples,aes(x=V1,y=V2)) + geom_path()
U(c(-1,5))
fGradSimpleX(1,1)
nIterations <- 100
lSamples <- Reduce(function(a,b) HMC1(b,a,U,grad_U,0.18,20,0.18),seq(1,nIterations),init = c(-2,-2),accumulate = T)
lSamples <- data.frame(matrix(unlist(lSamples),ncol=2,byrow = T))
View(lSamples)
HMCTest <- function (current_q, U, grad_U, epsilon, L,aP){
q = current_q
current_p = aP
# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest <- function (current_q, U, grad_U, epsilon, L,aP){
q = current_q
current_p = aP
# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest <- function (current_q, U, grad_U, epsilon, L,aP){
q = current_q
current_p = aP
p <- aP
# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
HMCTest <- function (current_q, U, grad_U, epsilon, L,aP){
q = current_q
current_p = aP
p <- aP
# Make a half step for momentum at the beginning
p = p - epsilon * grad_U(q) / 2
# Alternate full steps for position and momentum
for (i in 1:L)
{
# Make a full step for the position
q = q + epsilon * p
# Make a full step for the momentum, except at end of trajectory
if (i!=L) p = p - epsilon * grad_U(q)
}
# Make a half step for momentum at the end.
p = p - epsilon * grad_U(q) / 2
# Negate momentum at end of trajectory to make the proposal symmetric
p = -p
# Evaluate potential and kinetic energies at start and end of trajectory
current_U = U(current_q)
current_K = sum(current_p^2) / 2
proposed_U = U(q)
proposed_K = sum(p^2) / 2
#   print(current_U-proposed_U)
#   print(current_K-proposed_K)
print(q)
# Accept or reject the state at end of trajectory, returning either
# the position at the end of the trajectory or the initial position
r <- exp(current_U-proposed_U+current_K-proposed_K)
# print(r)
if (runif(1) < 1)
{
return (q)  # accept
}
else
{
return (current_q)  # reject
}
}
HMCTest(c(1,1),U,grad_U,0.18,20,c(0.1,0.1))
R.Version()
install.packages('googleVis')
library(ggplot2)
package_df <- as.data.frame(installed.packages("/Library/Frameworks/R.framework/Versions/2.15/Resources/library"))
.libPaths()
package_df <- as.data.frame(installed.packages("C:/Program Files/R/R-3.3.0/library"))
View(package_df)
package_df <- as.data.frame(installed.packages("C:/Program Files/R/R-3.2.2/library"))
View(package_df)
package_list <- as.character(package_df$Package)
install.packages(package_list)
install.packages(package_list)
install.packages(package_list)
install.packages(package_list)
library(ggplot2)
install.packages('plyr')
library(ggplot2)
install.packages('ggplot2')
library(ggplot2)
library(ggplot2)
R.Version()
R.Version()
rm(list=ls())
y <- data::nile
y <- datasets::Nile
plot(y,type='l')
?datasets::Nile
plot(y,type='l')
aStruct <- StructTS(y,type = 'level')
aStruct$code
if(aStruct$code!=0) stop('not converged')
print(aStruct$coef)
aStruct$fitted
plot(aStruct$fitted,type='l')
?StructTS
aStruct$model
KalmanRun(y,aStruct$model)
aStruct$fitted
KalmanRun(y,aStruct$model)
rm(list=ls())
library(rstan)
rstan_options(auto_write = TRUE)
setwd("C:/Users/Ben/Dropbox/Bayesian book/StanCode")
Y <- rnorm(10,1.5,0.2)
fit1 <- stan('StanJags_simpleNormal.stan',iter=100,chains=1,data=list(Y=Y))
